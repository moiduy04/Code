template<typename val_t, typename hold_t = int>
struct flow_edge{
	hold_t v;
	val_t flow,cap,cost;
	flow_edge() {}
	flow_edge(const hold_t& V, const val_t& capacity, const val_t& price, const val_t& passing_flow) : v (V), flow(passing_flow), cap(capacity), cost(price) {}
};
template<typename val_t, typename hold_t = int>
ostream& operator << (ostream &stream, const flow_edge<val_t,hold_t>& e){
	return stream << "--->" << e.v << " with (" << e.flow << '/' << e.cap << ')';
}
template<typename val_t, typename hold_t = int>
class flow_graph{
	val_t T_MAX = std::numeric_limits<val_t>::max();
	hold_t n; 
	vector<val_t> d;
	vector<hold_t> p,pe;
	queue<hold_t> q;
public:
	vt< vt<hold_t> > adjlist;
	vt< flow_edge<val_t,hold_t> > edge;
	
	flow_graph(const hold_t& N) : n(N) {adjlist.assign(N,vector<hold_t>());}

	void add(const hold_t &u, const hold_t &v, const val_t& cap = (val_t)1, const val_t& cost = 0, const val_t& currflow = 0)
	{
		adjlist[u].pb(edge.size());	edge.pb(flow_edge<val_t,hold_t>(v, cap, cost, currflow));
		adjlist[v].pb(edge.size());	edge.pb(flow_edge<val_t,hold_t>(u,   0,-cost,-currflow));
	}
	
	void SPFA(const hold_t& v0)
	{
		d.assign(n, T_MAX); d[v0] = 0;
		p.assign(n, hold_t(-1)); pe.assign(n, hold_t(-1));
		vector<bool> inq(n,false);
		q.push(v0);
		
		while(!q.empty())
		{
			hold_t u = q.front(); q.pop();
			inq[u] = false;
			for(hold_t i: adjlist[u])
			{
				flow_edge<val_t,hold_t> &e = edge[i];
				if (e.flow != e.cap && d[e.v] > d[u] + e.cost) 
				{
					d[e.v] = d[u] + e.cost, 
					p[e.v] = u,
					pe[e.v] = i;
					if (!inq[e.v])
					{
						inq[e.v] = true;
						q.push(e.v);
					}
				}
			}
		}
	}
	
	val_t min_cost_for_K(const hold_t& s, const hold_t& t, val_t K)
//	returns the minimum cost amongst all flows from s->t with flow value K, 
	{
		if (s ^ t)
		{
			val_t cost = 0, flow = 0;
			while(flow < K)
			{
				SPFA(s);
				if (p[t] == -1) break;
				
				val_t f = K - flow;
				hold_t curr = t;
				
				while(curr ^ s)
				{
					f = min(f, edge[pe[curr]].cap-edge[pe[curr]].flow);
					curr = p[curr];
				}
				
				flow += f;
				cost += f * d[t];
				
				curr = t;
				while(curr ^ s)
				{
					edge[pe[curr]].flow   += f,
					edge[pe[curr]^1].flow -= f;
					curr = p[curr];
				}
			}
			return cost;
		}
		return -1;
	}
	
	pair<val_t,val_t> min_cost(const hold_t& s, const hold_t& t, bool maxFlow = true)
//	returns a {cost, flow} pair;
	{
		if (s ^ t)
		{
			val_t cost = 0, flow = 0; 
			while(true)
			{
				SPFA(s);
				if (maxFlow)
				{
					if(d[t] == T_MAX) break;
				}
				else 
				{
					if (d[t] >= 0) break;
				}
				
				val_t f = T_MAX;
				hold_t curr = t;
				
				while(curr ^ s)
				{
					f = min(f, val_t(edge[pe[curr]].cap-edge[pe[curr]].flow));
					curr = p[curr];
				}
				
				flow += f, 
				cost += f * d[t];

				curr = t;
				while(curr ^ s)
				{
					edge[pe[curr]].flow   += f,
					edge[pe[curr]^1].flow -= f;
					curr = p[curr];
				}
			}
			return {cost,flow};
		}
		return {-1,-1};
	}
	
	bool bfs(const hold_t& s, const hold_t& t)
	{
		d.assign(n,-1); p.assign(n,0);
		q.push(s); d[s] = 0;
		
		while(!q.empty())
		{
			hold_t u = q.front(); q.pop();
			for(val_t i : adjlist[u])
			{
				hold_t v = edge[i].v;
				if (edge[i].cap != edge[i].flow && d[v] < 0)
				{
					d[v] = d[u]+1; q.push(v);
				}
			}
		}
		
		return d[t] >= 0;
	}
	
	val_t send_flow(const hold_t& u, const hold_t& t, const val_t& flow)
	{
		if(u == t || !flow) return flow;
		for(; p[u] < (hold_t)adjlist[u].size(); ++p[u])
		{
			hold_t i = p[u], j = adjlist[u][i], v = edge[j].v;
			if (edge[j].flow != edge[j].cap && d[v] == d[u]+1)
			{
				val_t temp = send_flow(v,t,min(val_t(edge[j].cap - edge[j].flow), flow));
				if (temp)
				{
					edge[ j ].flow += temp;
					edge[j^1].flow -= temp;
					return temp;
				}
			}
		}
		return 0;
	}
	
	val_t max_flow(const hold_t& s, const hold_t& t)
	{
		val_t ans = 0;
		while(bfs(s,t))
		{
			while(val_t flow = send_flow(s,t,T_MAX))
			{
				ans += flow;
			}
		}
		return ans;
	}
};
